---
title: "[만들면서 배우는 클린 아키텍처] 10. 아키텍처 경계 강제하기"
date: 2025-07-10 02:12:02 +0900
categories: [book, 만들면서 배우는 클린 아키텍처]
tags: [architecture, study]
image: /assets/img/study/clean_architecture/thumbnail.jpg
---

> 프로젝트가 진행되면서 아키텍처가 무너지지 않도록 경계를 강제하는 여러 가지 방법에 대해 알아보자.

---

## 경계와 의존성
![그림10.1](/assets/img/study/clean_architecture/example_image_10_1.png)
위 그림은 헥사고날 아키텍처의 요소들이 4개의 계층에서 어디에 위치하는지 보여준다.
가장 안쪽의 계층에는 도메인 엔티티가 있다. 애플리케이션 계층은 애플리케이션 서비스 안에 유스케이스를 구현하기 위해 도메인 엔티티에 접근한다. 어댑터는 인커밍 포트를 통해 서비스에 접근하고 반대로 서비스는 아웃고잉 포트를 통해 어댑터에 접근한다. 마지막으로 설정 계층은 어댑터와 서비스 객체를 생성할 팩터리를 포함하고 있고, 의존성 주입 매커니즘을 제공한다.

각 계층 사이, 안쪽 인접 계층과 바깥쪽 인접 계층 사이에 경계가 있고 의존성 규칙에 따라 계층 경계를 넘는 의존성은 항상 안쪽 방향으로 향해야 한다. 점선 화살표처럼 잘못된 방향을 가리키는 의존성을 없애보자.

---

## 접근 제한자
자바에는 접근 제한자가 `public`, `protected`, `private`와 `package-private`(혹은 default)가 존재한다.

이 중에서 `package-private` 제한자는 자바 패키지를 통해 클래스들을 응집적인 '모듈'로 만들어 주기 때문에 중요하다. 이러한 모듈 내에 있는 클래스들은 서로 접근 가능하지만, 패키지 바깥에서는 접근할 수 없다. 그러므로 모듈의 진입점으로 활용될 클래스들만 `public`으로 만들면 된다. 이렇게 하면 의존성이 잘못된 방향을 가리켜서 의존성 규칙을 위반할 위험이 줄어든다.

```text
buckpal
└── account
    ├── adapter
    │   ├── in
    │   │   └── web
    │   │       └── o AccountController
    │   └── out
    │       └── persistence
    │           ├── o AccountPersistenceAdapter
    │           └── o SpringDataAccountRepository
    ├── domain
    │   ├── + Account
    │   └── + Activity
    └── application
        └── o SendMoneyService
        └── Port
            ├── in
            │   └── + SendMoneyUseCase
            └── out
                ├── + LoadAccountPort
                └── + UpdateAccountStatePort
```
위와 같은 구조에서 `persistence` 패키지에 있는 클래스들은 외부에서 접근할 필요가 없기 때문에 `package-private`(위 트리에서 'o'로 표시)으로 만들 수 있다. 영속성 어댑터와 `SendMoneyService`는 자신이 구현하는 출력 포트를 통해 접근되므로 `package-private`로 만들 수 있다. 의존성 주입 매커니즘은 일반적으로 리플렉션을 이용해 클래스를 인스턴스로 만들기 때문에 `package-private`이더라도 인스턴스를 만들 수 있다.

이 방법을 스프링에서 사용하려면 9장에서 설명한 클래스패스 스캐닝을 이용해야 한다. 다른 방법에서는 객체의 인스턴스들을 우리가 직접 생성해야 하기 때문에 `public` 제한자를 이용해야 한다.

`domain` 패키지는 다른 계층에서 접근할 수 있어야 하고 `application` 계층은 `web` 어댑터와 `persistence` 어댑터에서 접근 가능해야 하므로 `public`('+'로 표시)이어야 한다.

`package-private` 제한자는 몇 개 정도의 클래스로만 이루어진 작은 모듈에서 가장 효과적이다. 패키지 내의 클래스가 많아지면 코드를 쉽게 찾을 수 있도록 하위 패키지를 만드는 것이 좋다. 이렇게 하면 자바는 하위 패키지를 다른 패키지로 취급하기 때문에 하위 패키지의 `package-private` 멤버에 접근할 수 없게 된다. 그러면 하위 패키지의 멤버는 `public`으로 만들어서 바깥에 노출시켜야 하기 때문에 의존성 규칙이 깨질 수 있는 환경이 된다.

---

## 컴파일 후 체크
클래스에 `public` 제한자를 쓰면 아키텍처 상의 의존성 방향이 잘못되더라도 컴파일러가 이를 잡아내지 못하기 때문에 의존성 규칙을 위반했는지 확인할 다른 수단을 찾아야 한다.

코드가 컴파일된 후에 런타임에 체크하는 컴파일 후 체크(post-compile check)를 도입하는 방법이 있다. 이러한 런타임 체크는 지속적인 통합 빌드 환경에서 자동화된 테스트 과정에서 가장 잘 동작한다.

이러한 체크를 도와주는 자바용 도구로 `ArchUnit`이 있다. 이는 의존성 방향이 기대한 대로 잘 설정돼 있는지 체크할 수 있는 API를 제공한다. 의존성 규칙 위반을 발견하면 예외를 던지고, `JUnit`과 같은 단위 테스트 프레임워크 기반에서 가장 잘 동작한다.
```java
class DependencyRuleTests {

    @Test
    void domainLayerDoesNotDependOnApplicationLayer() {
        noClasses()
            .that()
            .resideInPackage("buckpal.domain..")
            .should()
            .dependOnClassesThat()
            .resideInAnyPackage("buckpal.application..")
            .check(new ClassFileImporter()
                .importPackages("buckpal.."));
    }
}
```
각 계층이 전용 패키지를 가지고 있다고 가정하면 `ArchUnit`으로 도메인 계층에서 바깥쪽의 애플리케이션 계층으로 향하는 의존성이 없다는 것을 체크할 수 있다.

또한 헥사고날 아키텍처 내에서 관련된 모든 패키지를 명시할 수 있는 일종의 도메인 특화 언어(DSL)를 만들 수 있고, 패키지 사이의 의존성 방향이 올바른지 자동으로 체크할 수 있다.
```java
class DependencyRuleTests {

    @Test
    void validateRegistrationContextArchitecture() {
        HexagonalArchitecture.boundedContext("account")
            .withDomainLayer("domain")
            .withAdaptersLayer("adapter")
             .incoming("web")
             .outgoing("persistence")
             .and()
            .withApplicationLayer("application")
             .services("service")
             .incomingPorts("port.in")
             .outgoingPorts("port.out")
             .and()
            .withConfiguration("configuration")
            .check(new ClassFileImporter()
                .importPackages("io.reflectoring.buckpal.."));
    }
}
```
이 코드에서는 먼저 바운디드 컨텍스트의 부모 패키지를 지정한다. 그 다음 도메인, 어댑터, 애플리케이션, 설정 계층에 해당하는 하위 패키지들을 지정한다. 마지막으로 호출하는 `.check()`는 몇 가지 체크를 하고 패키지 의존성이 규칙을 따라 유효하게 설정됐는지 검증한다.

잘못된 의존성을 바로잡는 데 컴파일 후 체크가 큰 도움이 되긴 하지만 실패에 안전(fail-safe)하지는 않다. 패키지 이름인 buckpal에 오타를 내면 테스트가 어떤 클래스도 찾지 못하기 때문에 의존성 규칙 위반을 발견하지 못한다. 오타가 발생하거나 패키지명을 리팩터링한 경우 테스트 전체가 무의미해질 수 있다. 이런 상황을 방지하려면 클래스를 하나도 찾지 못했을 때 실패하는 테스트를 추가해야 한다. 리팩터링을 하는 경우 컴파일 후 체크 코드도 함께 변경해야 한다.

---

## 빌드 아티팩트
빌드 아티팩트는 빌드 프로세스의 결과물이다. 자바에서 가장 유명한 빌드 도구는 메이븐(Maven)과 그레이들(Gradle)이다. 메이븐 혹은 그레이들 스크립트로 메이븐이나 그레이들을 호출해서 코드를 컴파일하고, 테스트하고, 하나의 JAR 파일로 패키징할 수 있다.

빌드 도구의 주요한 기능 중 하나는 의존성 해결(dependency resolution)이다. 어떤 코드베이스를 빌드 아티팩트로 변환하기 위해 빌드 도구가 가장 먼저 할 일을 코드베이스가 의존하고 있는 모든 아티팩트가 사용 가능한 지 확인하는 것이다. 만약 사용 불가능한 것이 있다면 아티팩트 리포지토리로부터 가져오려고 시도한다. 이마저도 실패한다면 코드를 컴파일하기 전에 에러와 함께 빌드가 실패한다.

이를 활용해서 모듈과 아키텍처 계층 간의 의존성을 강제할 수 있다. 각 모듈 또는 계층에 대해 전용 코드베이스와 빌드 아티팩트로 분리된 빌드 모듈(JAR 파일)을 만들 수 있다. 각 모듈의 빌드 스크립트에서는 아키텍처에서 허용하는 의존성만 지정한다. 클래스들이 클래스패스에 존재하지도 않아 컴파일 에러가 발생하기 때문에 개발자들은 더이상 실수로 잘못된 의존성을 만들 수 없게 된다.

![그림10.3](/assets/img/study/clean_architecture/example_image_10_3.png)

위 그림은 아키텍처를 여러 개의 빌드 아티팩트로 나누는 몇 가지 선택지를 보여준다.

맨 왼쪽에는 설정, 어댑터, 애플리케이션 계층의 빌드 아티팩트로 이뤄진 기본적인 3개의 모듈 빌드 방식이 있다. 설정 모듈은 어댑터 모듈에 접근할 수 있고, 어댑터 모듈은 애플리케이션 모듈에 접근할 수 있다. 설정 모듈은 애플리케이션 모듈에도 접근할 수 있다.

어댑터 모듈은 영속성 어댑터뿐만 아니라 웹 어댑터도 포함하고 있다. 즉, 빌드 도구가 두 어댑터 간의 의존성을 막지 않을 것이라는 것이다. 의존성 규칙에는 문제가 없지만, 영속성 계층의 변경이 웹 계층에 영향을 미치거나 웹 계층의 변경이 영속성 계층에 영향을 주지 않기 위해서 서로 격리시키는 것이 좋다. (그림의 두 번째 열이 여기에 해당)

애플리케이션 모듈도 쪼갤 수 있다. 두 번째 열에서는 애플리케이션 모듈이 인커밍/아웃고잉 포트와 이러한 포트를 구현하거나 사용하는 서비스, 도메인 로직을 담은 도메인 엔티티를 모두 포함하고 있다.

도메인 엔티티가 포트에서 전송 객체(transfer object)로 사용되지 않는 경우라면(8장에서 언급한 매핑하지 않기 전략을 허용하지 않는 경우) 의존성 역전 원칙을 적용해서 포트 인터페이스만 포함하는 API 모듈을 분리해서 빼낼 수 있다. (그림의 세 번째 열이 해당)

어댑터 모듈과 애플리케이션 모듈은 API 모듈에 접근할 수 있지만, 반대는 불가능하다. API 모듈은 도메인 엔티티에 접근할 수도 없고 포트 인터페이스 안에서 도메인 엔티티를 사용할 수도 없다. 또한 어댑터는 더이상 엔티티와 서비스에 직접 접근할 수 없고 포트를 통해서 접근해야 한다.

더 나아가 API 모듈을 인커밍 포트와 아웃고잉 포트 각각만 가지고 있는 두 개의 모듈로 쪼갤 수 있다. (그림의 네 번째 열) 인커밍 포트나 아웃고잉 포트에 대해서만 의존성을 선언하여 특정 어댑터가 인커밍인지 아웃고잉인지 명확하게 정의할 수 있다.

서비스만 가지고 있는 모듈과 도메인 엔티티만 가지고 있는 모듈로 애플리케이션 모듈을 더 쪼갤 수도 있다. 이렇게 하면 엔티티가 서비스에 접근할 수 없어지고 도메인 빌드 아티팩트에 대한 의존성을 간단하게 선언하는 것만으로도 다른 애플리케이션이 같은 도메인 엔티티를 사용할 수 있게 된다.

실제로는 더 다양한 방법이 있고, 모듈을 더 세분화할수록 모듈 간의 의존성을 더 잘 제어할 수 있게 된다. 작게 분리할수록 모듈 간에 매핑을 더 많이 수행해야 하므로 8장에서 소개한 매핑 전략들 중 하나를 적절히 적용해야 한다.

빌드 모듈로 아키텍처 경계를 구분하는 것은 패키지로 구분하는 방식과 비교해 몇 가지 장점이 있다.
1. 빌드 도구는 순환 의존성(circular dependency)을 허용하지 않는다.
    - 순환 의존성은 하나의 모듈에서 일어나는 변경이 잠재적으로 순환 고리에 포함된 다른 모듈을 변경하게 만들며, 단일 책임 원칙을 위배하기 때문에 좋지 않다. 빌드 도구를 이용하면 빌드 모듈 간 순환 의존성이 없음을 확인할 수 있다.
2. 빌드 모듈 방식에서는 다른 모듈을 고려하지 않고 특정 모듈의 코드를 격리한 채로 변경할 수 있다.
    - 어댑터와 애플리케이션 계층이 같은 빌드 모듈에 있다면, 어댑터가 컴파일되지 않아도 애플리케이션 계층을 테스트할 수 있는 경우에도 컴파일 에러가 발생한다. 독립된 빌드 모듈로 구성한다면 테스트가 가능해진다.
    - 메이븐이나 그레이들로 빌드 프로세스를 실행하는 경우에도 격리한 채로 변경이 가능해진다.
3. 모듈 간 의존성이 빌드 스크립트에 분명하게 선언되어 있다.
    - 새로 의존성을 추가하는 일이 의식적인 행동이 되기 때문에 한 번 더 생각하고 신중하게 결정하도록 유도한다.

하지만 이러한 장점들은 유지보수 비용을 수반하기 때문에 빌드 모듈로 나누기 전에 아키텍처가 어느 정도는 안정된 상태여야 한다.

---

## 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?
기본적으로 소프트웨어 아키텍처에서는 요소 간의 의존성을 관리하는 것이 중요하다. 

새로운 코드를 추가하거나 리팩터링할 때 패키지 구조를 항상 염두해야 하고, 가능하다면 `package-private`을 이용해 패키지 바깥에서 접근하면 안 되는 클래스에 대한 의존성을 피해야 한다.

하나의 빌드 모듈 안에서 아키텍처 경계를 강제해야 하고, 패키지 구조가 허용하지 않아 `package-private` 제한자를 사용할 수 없다면 `ArchUnit` 같은 컴파일 후 체크 도구를 이용해야 한다.

아키텍처가 충분히 안정적이라고 느껴지면 아키텍처 요소를 독립적인 빌드 모듈로 분리하여 의존성을 분명하게 제어할 수 있다. 