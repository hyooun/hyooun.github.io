---
title: "클린 아키텍처 01. 계층형 아키텍처의 문제는 무엇일까?"
date: 2025-06-26 20:00:00 +0900
categories: [book, clean architecture]
tags: [architecture]
---
## 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다.

전통적인 계층형 아키텍처는 웹 계층은 도메인 계층에 의존하고, 도메인 계층은 영속성 계층에 의존하기 때문에 자연스레 데이터베이스에 의존하게 된다. 계층형 아키텍처에서는 의존성의 방향에 따라 자연스럽게 데이터 구조를 먼저 생각하고, 이를 토대로 도메인 로직을 구현하게 되는데 이는 비즈니스 관점에서는 좋지 않은 방법이다. 우리가 로직을 제대로 이해했는지 확인하기 위해서는 도메인 로직을 먼저 만들고 이를 기반으로 영속성 계층과 웹 계층을 만들어야 한다.

이러한 데이터베이스 중심적인 아키텍처가 만들어지는 가장 큰 원인은 JPA나 Hibernate와 같은 ORM 프레임워크를 사용하기 때문이다. ORM에 의해 관리되는 엔티티들은 일반적으로 영속성 계층에 두고 계층은 아래 방향으로만 접근 가능하기 때문에 도메인 계층에서는 이러한 엔티티에 접근이 가능하다. 이러한 접근이 가능하다 보니 사용되기 마련이고 영속성 계층과 도메인 계층 사이에 강한 결합이 생긴다. 서비스는 영속성 모델을 비즈니스 모델처럼 사용하게 되고 이로 인한 도메인 로직뿐만 아니라 즉시로딩(eager loading), 지연로딩(lazy loading), 데이터베이스 트랜잭션, 캐시 플러시 등등 영속성 계층과 관련된 작업들을 해야만 한다. 이처럼 영속성 코드가 도메인 코드에 뒤섞이게 되면 둘 중 하나만 바꾸는 것이 어려워진다.

## 지름길을 택하기 쉬워진다.

전통적인 계층형 아키텍처에서 전체적으로 적용되는 유일한 규칙은, 특정한 계층에서 같은 계층이나 아래에 있는 계층에만 접근이 가능하다는 것이다. 만약 상위 게층에 위치한 컴포넌트에 접근해야 한다면 컴포넌트의 게층을 내려 접근 가능하게 만들 수 있다.

이러한 선택지가 존재하는 것 자체가 누군가 그렇게 할 가능성이 존재한다는 것을 의미하고, 만약 한 사람이 그렇게 했다면 재차 그렇게 하는 것에 대한 심리적 부담감이 줄어들어 점점 엉망이 될 것이다.

영속성 계층은 컴포넌트를 아래 계층으로 내릴수록 점점 커지고, 어떤 게층에도 속하지 않는 것 처럼 보이는 헬퍼 컴포넌트나 유틸리티 컴포넌트들이 포함될 가능성이 크다.

이러한 불상사를 방지하기 위해서는 추가적인 규칙을 강제하여 지키지 않는 경우 빌드가 불가능하도록 만들어야 한다.

## 테스트하기 어려워진다.

계층형 아키텍처를 사용할 때 일반적으로 나타나는 변화의 형태는 계층을 건너뛰는 것이다. 엔티티의 필드를 단 하나만 조작하면 되는 경우에 웹 계층에서 바로 영속성 계층에 접근하면 도메인 계층을 거칠 필요가 없을 것이다.

하지만 이러한 방식을 사용하게 되면 두 가지 문제점이 생긴다.

첫 번째 문제는 단 하나의 필드를 조작하는 것에 불과하더라도 도메인 로직을 웹 계층에 구현하게 된다는 것이다. 추후에 유스케이스가 확장된다면 더 많은 도메인 로직을 웹 계층에 추가해서 애플리케이션 전반에 걸쳐 책임이 섞이게 된다.

두 번째 문제는 웹 계층 테스트에서 도메인 계층뿐만 아니라 영속성 게층도 모킹(mocking)해야 한다는 것이다. 이렇게 되면 단위 테스트의 복잡도가 올라간다. 웹 컴포넌트의 규모가 커질수록 다양한 영속성 컴포넌트에 의존성이 많이 쌓이면서 테스트 복잡도를 높이고 목(mock)을 만드는 데 더 많은 시간이 소요될 것이다.

## 유스케이스를 숨긴다.

개발자들은 새로운 유스케이스를 구현하는 새로운 코드를 짜는 것 보다 기존 코드를 바꾸는 데 더 많은 시간을 사용한다. 기능을 추가하거나 변경할 일이 많기 때문에 아키텍처는 코드를 빠르게 탐색하기에 편리해야 한다.

하지만 앞서 언급했듯이 계층형 아키텍처는 도메인 로직이 여러 계층에 걸쳐 흩어지기 쉽다. 유스케이스가 간단해서 도메인 게층을 생략한다면 웹 계층에 존재할 수도 있고, 도메인 계층과 영속성 계층 모두에서 접근할 수 있도록 특정 컴포넌트를 아래로 내렸다면 영속성 계층에 존재할 수도 있다. 이럴 경우 새로운 기능을 추가할 적당한 위치를 찾는 일이 어려워진다.

심지어 계층형 아키텍처는 도메인 서비스의 '너비'에 대한 규칙을 강제하지 않는다. 여러 개의 유스케이스를 담당하는 폭 넓은 서비스가 만들어질 수 있다. 넓은 서비스는 영속성 계층에 많은 의존성을 갖게 되고, 웹 레이어의 많은 컴포넌트가 이 서비스에 의존하게 된다. 그럼 테스트를 하기도 어려워지고 유지보수도 어려워진다.

`UserService` 대신 `ResisterUserService`라면 사용자 등록 유스케이스를 찾는 것이 쉬운 것 처럼 특화된 도메인 서비스가 유스케이스 하나만을 담당하게 한다면 이러한 작업들은 수월해진다.

## 동시 작업이 어려워진다.

계층형 아키텍처에서는 모든 것이 영속성 계층 위에서 만들어지기 때문에 영속성 계층을 먼저 개발해야 하고 그 다음에 도메인 계층을 그리고 마지막으로 웹 계층을 만들어야 한다. 때문에 특정 기능은 동시에 한 명의 개발자만 작업할 수 있다.

개발자들이 인터페이스를 먼저 같이 정의하고 각 개발자들이 실제 구현을 기다릴 필요 없이 이 인터페이스들로 작업할 수 있지만, 이는 데이터베이스 주도 설계를 하지 않는 경우에만 가능하다.

넓은 서비스가 존재한다면 서로 다른 기능을 동시에 작업하기가 더욱 어려워진다. 서로 다른 유스케이스에 대한 작업을 하게 되면 같은 서비스를 동시에 편집하는 상황이 발생하고, 이는 병합 충돌(merge confilct)과 같은 문제를 야기할 수 있다.

## 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

계층형 아키텍처를 만들어봤다면 이러한 단접들이 익숙하고, 심지어 다른 단점들도 더 겪어봤을 수 있다. 올바르게 구축하고 몇 가지 규칙들을 적용하면 계층형 아키텍처는 유지보수하기 매우 쉬워지며 코드를 쉽게 변경하거나 추가할 수 있게 된다.

그러나 앞에서 살펴봤듯이 계층형 아키텍처는 많은 것들이 잘못된 방향으로 흘러갈 수 있는 여지를 제공한다. 엄격한 규칙 없이는 시간이 지날수록 품질이 저하되고 유지보수하기 어려워질 수 있다.

## 1장 느낀점?

계층형 아키텍처로 개발한 경험이 있어서 실제로 겪어본 문제점들이라서 읽으면서 많이 뜨끔했다... 
구분하기 어려운 유틸리티는 영속성 계층에 넣어뒀던 것 같고 서비스가 점점 넓어지면서 더 많은 영속성 계층과 점점 많은 결합이 생겼던 것 같다. 설계하고 개발을 시작할때도 항상 DB 테이블부터 만들어놓고 꼭 나중에 수정했었고 같은 서비스 동시에 작업해서 충돌난적도 많았다. 무식하게 개발했던걸 반성하면서 이 책 읽고 이것저것 찾아보고 공부하면서 앞으론 그러지 말아야지