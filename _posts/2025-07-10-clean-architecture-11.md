---
title: "[만들면서 배우는 클린 아키텍처] 11. 의식적으로 지름길 사용하기"
date: 2025-07-10 13:37:07 +0900
categories: [book, 만들면서 배우는 클린 아키텍처]
tags: [architecture, study]
image: /assets/img/study/clean_architecture/thumbnail.jpg
---

> 프로젝트를 진행하다 보면 지름길의 유혹을 느낄 수 있다. 우발적으로 사용된 지름길을 인식하고 수정할 수 있게, 그리고 정당한 지름길이라면 의식적으로 선택할 수 있게 지름길을 파악해보자.

## 왜 지름길은 깨진 창문 같을까?
깨진 창문 이론이 코딩에 적용될 때의 의미는 다음과 같다.
- 품질이 떨어진 코드에서 작업할 때 더 낮은 품질의 코드를 추가하기가 쉽다.
- 코딩 규칙을 많이 어긴 코드에서 작업할 때 또 다른 규칙을 어기기도 쉽다.
- 지름길을 많이 사용한 코드에서 작업할 때 또 다른 지름길을 추가하기도 쉽다.

많은 레거시 코드들의 품질이 시간이 가면서 심하게 낮아지는 것도 이러한 깨진 창문 이론의 영향이 컸을 것이다.

---

## 깨끗한 상태로 시작할 책임
소프트웨어 프로젝트는 비용과 시간이 많이 들기 때문에 깨진 창문을 막는 것은 개발자들의 책임이다. 프로젝트를 마무리하지 못하고 다른 이들이 프로젝트를 인계받을 수 있는데, 깨진 상태라면 깨진 창문이 생기기 쉽다.

프로젝트 전체로 봤을 때 그리 중요하지 않은 부분이거나, 프로토타이핑 작업 중이거나, 경제적인 이유 등으로 지름길을 취하는 것이 더 실용적일 때도 있다.

이러한 의도적인 지름길에 대해서는 세심하게 잘 기록해 두어야 한다. 팀원 모두가 이 문서에 대해 인지하고 있다면 지름길이 합리적인 이유에 의해 의도적으로 추가되었다는 사실을 인지하고 있기 때문에 깨진 창문 이론의 영향을 줄일 수 있다.

---

## 유스케이스 간 모델 공유하기
![그림11.1](/assets/img/study/clean_architecture/example_image_11_1.png)

위 그림은 두 개의 유스케이스가 같은 입력 모델을 공유하는 예를 보여준다.

공유로 인한 영향은 `SendMoneyUseCase`와 `RevokeActivityUseCase`가 결합된다는 것이다. 공유되고 있는 `SendMoneyCommand` 클래스가 변경되면 두 유스케이스가 모두 영향을 받는다. 단일 책임 원칙에서 이야기하는 '변경할 이유'를 공유하는 것이다. 출력 모델을 공유하는 경우에도 마찬가지다.

유스케이스 간 입출력 모델을 공유하는 것은 유스케이스들이 기능적으로 묶여 있을 때 유효하다. 이 경우 특정 세부사항을 변경할 경우 두 유스케이스 모두에 영향을 주고 싶은 것이다.

두 유스케이스가 서로 미치는 영향 없이 독립적으로 개발해야 한다면 입출력 모델을 공유하는 방식은 지름길이 된다. 처음에는 똑같은 입출력 클래스를 복사해야 하더라도 일단 분리해서 시작하는 것이 정석이다.

그러므로 비슷한 개념의 유스케이스 여러 개를 만든다면 유스케이스를 독립적으로 개발할 필요가 있는지 주기적으로 확인해야 한다. 그렇다고 판단되는 시점이 입출력 모델을 분리할 시점이다.

---

## 도메인 엔티티를 입출력 모델로 사용하기
![그림11.2](/assets/img/study/clean_architecture/example_image_11_2.png)

도메인 엔티티인 `Account`와 인커밍 포트인 `SendMoneyUseCase`가 있으면 엔티티를 인커밍 포트의 입출력 모델로 사용할 수 있다. 이 경우 인커밍 포트는 도메인 엔티티에 의존성을 가지고 있다. 그 결과 `Account` 엔티티는 변경할 이유가 추가되었다.

`Account` 엔티티는 인커밍 포트인 `SendMoneyUseCase`에 의존성이 없는데(의존성 방향이 반대) 인커밍 포트가 어떻게 변경할 이유가 된다는 것일까?

현재 `Account` 엔티티에 없는 정보를 유스케이스가 필요로 한다고 생각해보자. 이 정보는 최종적으로 `Account`가 아닌 다른 도메인이나 바운디드 컨텍스트에 저장돼야 한다. 그럼에도 이미 유스케이스 인터페이스에서 사용할 수 있기 때문에 `Account` 엔티티에 필드로 추가하고 싶을 수 있다.

간단한 생성이나 업데이트 유스케이스에서는 유스케이스 인터페이스에 도메인 엔티티가 있는 것이 괜찮을 수 있지만, 단순히 데이터베이스 필드 몇 개를 업데이트하는 수준이 아니라 더 복잡한 도메인 로직을 구현해야 한다면 유스케이스 인터페이스에 대한 전용 입출력 모델을 만들어야 한다. 유스케이스의 변경이 도메인 엔티티까지 영향을 미치지 않게 하기 위함이다.

이 지름길이 위험한 이유는 많은 유스케이스가 간단한 생성 또는 업데이트 유스케이스로 시작하지만 시간이 지나며 도메인 로직이 점점 복잡해지기 때문이다. 이는 최소 기능 제품(minimum viable product)으로 시작해서 점점 복잡도를 높여가는 애자일 환경에서 더욱 그렇다. 처음에는 도메인 엔티티를 입력 모델로 사용했더라도 독립적인 전용 입력 모델로 교체할 시점을 잘 파악해야 한다.

---

## 인커밍 포트 건너뛰기
아웃고잉 포트는 애플리케이션 계층과 아웃고잉 어댑터 사이의 의존성을 역전시키기 위한 필수 요소인 반면 인커밍 포트는 의존성 역전에 필수 요소는 아니다. 인커밍 어댑터가 인커밍 포트 없이 애플리케이션 서비스에 직접 접근하도록 할 수 있다.

![그림11.3](/assets/img/study/clean_architecture/example_image_11_3.png)

인커밍 포트를 제거함으로써 인커밍 어댑터와 애플리케이션 계층 사이의 추상화 계층을 줄였다. 추상화 계층을 줄이는 것이 괜찮게 느껴질 수 있지만, 인커밍 포트는 애플리케이션 중심에 접근하는 진입점을 의미한다. 전용 인커밍 포트를 유지하면 진입점을 식별하기 쉽고, 새로운 개발자가 코드를 파악하는 데 도움이 된다.

인커밍 포트를 유지해야 하는 또 다른 이유는 아키텍처를 쉽게 강제할 수 있기 때문이다. 10장에서 언급한 아키텍처를 강제하는 옵션들을 이용하면 인커밍 어댑터가 애플리케이션 서비스가 아닌 인커밍 포트만 호출하게 할 수 있다. 이렇게 하면 애플리케이션 계층에 대한 진입점을 정의하는 것이 의식적인 결정이 되어 실수가 발생할 확률이 줄어든다.

애플리케이션 규모가 작거나 인커밍 어댑터가 하나밖에 없어서 모든 제어 흐름을 인커밍 포트의 도움 없이 단숨에 파악할 수 있다면 인커밍 포트가 없는 것이 편하다. 그러나 추후 확장성을 고려한다면, 인커밍 포트를 유지하는 편이 낫다.

---

## 애플리케이션 서비스 건너뛰기
![그림11.4](/assets/img/study/clean_architecture/example_image_11_4.png)

어떤 유스케이스에서는 애플리케이션 계층을 건너뛰고 싶을 수 있다. 위 그림에서 아웃고잉 어댑터에 있는 `AccountPersistenceAdapter` 클래스는 직접 인커밍 포트를 구현해서 일반적으로 인커밍 포트를 구현하는 애플리케이션 서비스를 대체한다.

간단한 CRUD 유스케이스에서는 보통 애플리케이션 서비스가 도메인 로직 없이 요청을 그대로 영속성 어댑터에 전달하기 때문에 효과적이다. 그대로 전달하는 대신 영속성 어댑터가 직접 유스케이스를 구현하게 할 수도 있다.

하지만 이 방법은 인커밍 어댑터와 아웃고잉 어댑터 사이에 모델을 공유해야 한다. 이 경우엔 공유해야 하는 모델이 `Account` 도메인 엔티티이므로 앞에서 이야기한 도메인 모델을 입력 모델로 사용하는 케이스가 된다.

이렇게 되면 애플리케이션 코어에 유스케이스라고 할 만한 것이 없어진다. 시간이 지나 CRUD 유스케이스가 점점 복잡해지면, 이미 유스케이스가 어댑터에 있으니 도메인 로직을 그대로 아웃고잉 어댑터에 추가하게 된다. 도메인 로직이 흩어지면 도메인 로직을 찾거나 유지보수하기가 어려워진다.

보일러플레이트 코드가 많아지는 것을 방지하기 위해 간단한 CRUD 케이스에서는 애플리케이션 서비스를 건너뛰기로 결정할 수 있다. 하지만 유스케이스가 단순한 CRUD를 넘어서는 일을 하게 되면 애플리케이션 서비스를 만든다는 명확한 가이드라인을 팀에 정해둬야 한다.

---

## 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?
효율성 측면에서 지름길이 합리적인 선택일 수 있다. 간단한 CRUD 유스케이스에 대해서는 전체 아키텍처를 구현하는 것이 지나치게 느껴지기 때문에 유혹을 느낄 수 있지만, 단순한 CRUD에서 벗어나는 시점이 언제인지 팀에서 합의하고 장기적으로 유지보수하기 좋은 아키텍처로 대체해야 한다.