---
title: "[만들면서 배우는 클린 아키텍처] 02. 의존성 역전하기"
date: 2025-06-27 12:00:00 +0900
categories: [book, 만들면서 배우는 클린 아키텍처]
tags: [architecture, study]
image: /assets/img/study/clean_architecture/thumbnail.jpg
---

> 이 장에서는 SOLID 원칙에서 'S'와 'D'를 담당하는 단일 책임 원칙(Single Responsibility Principle, SRP)과 의존성 역전 원칙(Dependency Inversion Principle, DIP)에 대해서 주로 이야기한다.

---

## 단일 책임 원칙

단일 책임 원칙을 직관적으로 해석하면 "하나의 컴포넌트는 오로지 한 가지 일만 해야 하고, 그것을 올바르게 수행해야 한다."로 이해할 수 있다. 하지만 실제 정의는 "컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다."이다.

컴포넌트를 변경할 이유가 오로지 한 가지라면 컴포넌트는 한 가지 일만 하게 된다. 또한 우리가 어떤 다른 이유로 소프트웨어를 변경하더라도 이 컴포넌트에 대해서는 전혀 신경쓰지 않아도 된다. 단일 책임 원칙을 지키지 않아 컴포넌트 간 의존성이 높을수록 이러한 변경할 이유가 생길 가능성이 커지고, 시간이 지날수록 변경 비용이 증가한다.

하나의 컴포넌트가 한 가지 일을 하더라도 여러 컴포넌트에 의존하고 있어 다른 컴포넌트가 변경되었을 때 함께 변경하지 않도록 컴포넌트를 나누어야 한다는 것 같다. (컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다는 개념이 더 좁은 개념인듯함)

---

## 의존성 역전 원칙

계층형 아키텍처에서 계층 간 의존성은 항상 다음 계층인 아래 방향을 가리킨다. 단일 책임 원칙을 고수준에서 적용할 때 상위 계층들이 하위 계층들에 비해 변경할 이유가 더 많다는 것을 알 수 있다.

그러므로 영속성 계층에 대한 도메인 계층의 의존성 때문에 영속성 계층을 변경할 때마다 잠재적으로 도메인 계층도 변경해야 한다. 그러나 도메인 코드는 애플리케이션에서 가장 중요한 코드이고 영속성 코드가 바뀐다고 함께 바꾸는 것은 좋지 않다.

이는 "코드상의 어떤 의존성이든 그 방향을 바꿀 수(역전시킬 수) 있다."는 의존성 역전 원칙을 통해 해결할 수 있다. 의존성의 양쪽 코드를 모두 제어할 수 있을 때만 가능하다. 만약 서드파티 라이브러리에 의존성이 있다면 해당 라이브러리를 제어할 수 없기 때문에 역전이 불가능하다.

도메인 코드와 영속성 코드 간의 의존성을 역전시켜서 영속성 코드가 도메인 코드에 의존하고, 도메인 코드를 '변경할 이유'의 개수를 줄일 수 있다. 도메인 계층의 서비스가 영속성 계층의 엔티티와 리포지토리에 의존하고, 리포지토리는 엔티티에 의존하는 경우를 생각해보자.

엔티티는 도메인 객체를 표현하고 도메인 코드는 이 엔티티들의 상태를 변경하는 일을 중심으로 하기 때문에 먼저 엔티티를 도메인 계층으로 올린다. 그러나 이제는 영속성 계층의 리포지토리가 도메인 계층에 있는 엔티티에 의존하기 때문에 두 계층 사이에 순환 의존성(circular dependency)이 생긴다.

여기서 DIP를 적용하여 도메인 계층에 리포지토리에 대한 인터페이스를 만들고, 실제 리포지토리는 영속성 계층에서 구현하게 만들면 해결할 수 있다. 리포지토리 구현체는 도메인 계층의 엔티티에 의존하는 것이 아닌, 영속성 계층의 ORM이 관리하는 엔티티에만 의존하게 된다. 이 개념이 클린 아키텍처와 헥사고날 아키텍처의 핵심이다.

---

## 클린 아키텍처

클린 아키텍처의 가장 핵심이 되는 개념은 도메인 코드가 바깥으로 향하는 어떤 의존성도 없어야 함을 의미한다. 대신 의존성 역전 원칙의 도움으로 모든 의존성이 도메인 코드를 향하고 있다.

> ![클린 아키텍처](/assets/img/study/clean_architecture/clean-architecture.png)
이미지 출처 : [https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)

이 아키텍처의 코어에는 주변 유스케이스에서 접근하는 도메인 엔티티들이 있다. 유스케이스는 앞에서 불렀던 서비스에 해당하는데, 단일 책임(변경할 단 한 가지의 이유)을 위해 더 세분화된 개념이다. 이를 통해 1장에서 언급했던 넓은 서비스 문제를 피할 수 있다.

다음 계층엔 비즈니스 규칙을 지원하는 애플리케이션의 다른 모든 컴포넌트들을 확인할 수 있다. (여기서 '지원'은 영속성을 제공하거나 UI를 제공하는 것 등을 의미한다.) 또한 가장 바깥쪽 계층들은 다른 서드파티 컴포넌트에 어댑터를 제공할 수 있다.

도메인 코드에서는 어떤 영속성 프레임워크나 UI 프레임워크가 사용되는지 알 수 없기 때문에 특정 프레임워크에 특화된 코드를 가질 수 없고 비즈니스 규칙에 집중할 수 있다. 도메인 코드를 자유롭게 모델링할 수 있어 도메인 주도 설계(Domain-Driven Design, DDD)를 적용하기도 수월해진다.

클린 아키텍처를 사용하는 대가는 존재한다. 도메인 계층이 영속성이나 UI와 같은 외부 계층과 철저하게 분리돼야 하므로 애플리케이션의 엔티티에 대한 모델을 각 계층에서 유지보수해야 한다.

영속성 계층에서 ORM(object-relational mapping) 프레임워크를 사용한다고 해보자. 일반적인 ORM 프레임워크는 데이터베이스 구조 및 객체 필드와 데이터베이스 칼럼의 매핑을 서술한 메타데이터를 담고 있는 엔티티 클래스를 필요로 한다. 도메인 계층은 영속성 계층을 모르기 때문에 도메인 계층에서 사용한 엔티티 클래스를 영속성 계층에서 사용할 수 없고 두 계층에서 각각 엔티티를 만들어야 한다. 즉, 도메인 계층과 영속성 계층이 데이터를 주고받을 때, 두 엔티티를 서로 변환해야 한다는 뜻이다.

이는 번거롭긴 하지만 특정 프레임워크에 의존하지 않는 결합이 제거된 상태이다. 예를 들어, JPA(Java Persistence API)에서는 ORM이 관리하는 엔티티에 인자가 없는 기본 생성자를 추가하도록 강제하지만 특정 프레임워트에 특화되지 않기 위해 도메인 모델에는 포함되면 안된다.

---

## 육각형 아키텍처(헥사고날 아키텍처)
> ![헥사고날 아키텍처](/assets/img/study/clean_architecture/hexagonal-architecture.png)
이미지 출처 : [https://reflectoring.io/spring-hexagonal/](https://reflectoring.io/spring-hexagonal/)

애플리케이션 코어가 육각형으로 표현되어 지어진 이름이다. 애플리케이션이 다른 시스템이나 어댑터와 연결되는 4개 이상의 면을 가질 수 있음을 보여주기 위해 일반적인 사각형 대신 육각형을 사용했다는 설도 있다.

육각형 안에는 도메인 엔티티와 이와 상호작용하는 유스케이스가 있고, 육각형에서 외부로 향하는 의존성이 없기 때문에 클린 아키텍처에서 제시한 의존성 규칙이 그대로 적용된다. 

육각형 바깥에는 애플리케이션과 상호작용하는 다양한 어댑터들이 있다. 웹 브라우저와 상호작용하는 웹 어댑터도 있고, 일부 어댑터는 외부 시스템과 상호작용하며, 데이터베이스와 상호작용하는 어댑터도 있다.

왼쪽에 있는 어댑터들은 애플리케이션 코어를 호출하기 때문에 애플리케이션을 주도하는 어댑터들이다. 반면 오른쪽에 있는 어댑터들은 애플리케이션 코어에 의해 호출되기 때문에 애플리케이션에 의해 주도되는 어댑터들이다.

애플리케이션 코어와 어댑터들 간의 통신이 가능하려면 애플리케이션 코어가 각각의 포트를 제공해야 한다. 왼쪽의 주도하는 어댑터(driving adapter)에게는 그러한 포트가 코어에 있는 유스케이스 클래스 중 하나에 구현되고 어댑터에 의해 호출되는 인터페이스가 될 것이고, 오른쪽의 주도되는 어댑터(driven adapter)에게는 그러한 포트가 어댑터에 의해 구현되고 코어에 의해 호출되는 인터페이스가 될 것이다.

이러한 핵심 개념으로 이 아키텍처 스타일은 '포트와 어댑터(ports-and-adapters)' 아키텍처로도 알려져 있다.

---

## 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?
두 아키텍처 모두 의존성을 역전시켜 도메인 코드가 다른 바깥쪽 코드에 의존하지 않게 함으로써 영속성과 UI에 특화된 모든 문제로부터 도메인 로직의 결합을 제거하고 코드를 변경할 이유의 수를 줄일 수 있다. (변경할 이유가 적을수록 유지보수성은 더 좋아진다.)

또한 도메인 코드는 비즈니스 문제에 딱 맞도록 자유롭게 모델링될 수 있고, 영속성 코드와 UI 코드도 영속성 문제와 UI 문제에 딱 맞게 각자 자유로운 모델링이 가능해진다.

다음 장 부터는 웹 애플리케이션에 육각형 아키텍처 스타일을 적용하여 패키지 구조를 만들고 의존성 주입의 역할에 대해 이야기하며 시작해보자.

---

## 2장 느낀점?
머릿속에 흩어져 있던 개념들을 정리할 수 있었고 계속해서 언급되고 있는 클린 아키텍처(지금까지 학습한 짧은 지식으로는 클린 아키텍처가 헥사고날을 포함하고 있는 개념인 듯 하다)와 DDD 등 개발자는 도메인 로직에만 집중할 수 있도록 만들자는 트렌드가 계속해서 이어지지 않을까 싶다.