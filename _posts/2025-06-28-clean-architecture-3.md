---
title: "[만들면서 배우는 클린 아키텍처] 03. 코드 구성하기"
date: 2025-06-28 01:49:33 +0900
categories: [book, 만들면서 배우는 클린 아키텍처]
tags: [architecture, study]
image: /assets/img/study/clean_architecture/thumbnail.jpg
---

> 이 장에서는 코드를 구성하는 몇 가지 방법을 살펴보고 헥사고날 아키텍처를 반영한 패키지 구조를 BuckPal 예제와 함께 알아보자.

## 계층으로 구성하기
```text
buckpal
├── domain
│   ├── Account
│   ├── Activity
│   ├── AccountRepository
│   └── AccountService
├── persistence
│   └──AccountRepositoryImpl
└── web
    └── AccountController
```

웹 계층, 도메인 계층, 영속성 계층 각각에 대해 전용 패키지인 `web`, `domain`, `persistence`를 뒀다. 의존성 역전 원칙을 적용하여 의존성이 `domain` 패키지에 있는 도메인 코드만을 향하도록 구성되어 있다. 여기서는 `domain` 패키지에 `AccountRepository` 인터페이스를 추가하고, `persistence` 패키지에 `AccountRepositoryImpl` 구현체를 둠으로써 의존성을 역전시켰다.

그러나 다음과 같은 세 가지 이유로 이 패키지 구조는 최적이 아니다.
1. 애플리케이션의 기능 조각(functional slice)이나 특성(feature)을 구분 짓는 패키지 경계가 없다.
    > 이 구조에서 사용자를 관리하는 기능을 추가해야 한다면 `web` 패키지에 `UserController`를 추가하고, `domain` 패키지에 `UserService`, `UserRepository`, `User`를 추가하고 `persistence` 패키지에 `UserRepositoryImpl`을 추가해야 한다. 추가적인 구조가 없다면, 연관되지 않은 기능들끼리 예상치 못한 부수효과(side effect)를 일으킬 수 있다.
2. 애플리케이션이 어떤 유스케이스들을 제공하는지 파악할 수 없다.
    > `AccountService`와 `AccountController`가 어떤 유스케이스를 구현했는지 파악하기 어렵다. 특정 기능을 찾기 위해서는 어떤 서비스가 이를 구현했는지 추측해야 하고, 해당 서비스 내의 어떤 메서드가 그에 대한 책임을 수행하는지 찾아야 한다.
3. 패키지 구조를 통해서 아키텍처를 파악할 수 없다.
    > 헥사고날 아키텍처라는 것을 파악했더라도, 어떤 기능이 웹 어댑터에서 호출되는지, 영속성 어댑터가 도메인 계층에 어떤 기능을 제공하는지 한눈에 알아볼 수 없다. 인커밍(incoming) 포트와 아웃고잉(outgoing) 포트가 코드 속에 숨겨져 있다.

## 기능으로 구성하기
```text
buckpal
└── account
    ├── Account
    ├── AccountController
    ├── AccountRepository
    ├── AccountRepositoryImpl
    └── SendMoneyService
```
위 구조는 예제를 기능으로 구성한 것이다. 가장 본질적인 변경은 계좌와 관련된 모든 코드를 최상위의 `account` 패키지에 넣었다는 점이다. 계층 패키지들도 없앴다.

각 기능을 묶은 새로운 그룹은 `account`와 같은 레벨의 새로운 패키지로 들어가고, 패키지 외부에서 접근되면 안 되는 클래스들에 대해 `packace-private` 접근 수준을 이용해 패키지 간의 경계를 강화할 수 있다. 이를 통해 각 기능 사이의 불필요한 의존성을 방지할 수 있다.

또한 `AccountService`의 책임을 좁히기 위해 `SendMoneyService`로 클래스명을 바꿨다. 이제 '송금하기' 유스케이스를 구현한 코드는 클래스명만으로도 찾을 수 있게 되었다.

그러나 기능에 의한 패키징 방식은 계층에 의한 패키징 방식보다 아키텍처의 가시성을 더 떨어뜨린다. 어댑터를 나타내는 패키지명이 없고, 인커밍 포트, 아웃고잉 포트를 확인할 수 없다. 심지어 도메인 코드와 영속성 코드 간의 의존성을 역전시켜서 `SendMoneyService`가 `AccountRepository` 인터페이스만 알고 있고 구현체는 알 수 없도록 했음에도 불구하고 `package-private` 접근 수준을 이용해 도메인 코드가 실수로 영속성 코드에 의존하는 것을 막을 수 없다. (같은 패키지 내에 있으므로)

## 아키텍처적으로 표현력 있는 패키지 구조
헥사고날 아키텍처에서 구조적으로 핵심적인 요소는 엔티티, 유스케이스, 인커밍/아웃고잉 포트, 인커밍/아웃고잉(혹은 주도하거나 주도되는) 어댑터다. 이 요소들을 패키지 구조에 잘 녹여보자.
```text
buckpal
└── account
    ├── adapter
    │   ├── in
    │   │   └── web
    │   │       └── AccountController
    │   └── out
    │       └── persistence
    │           ├── AccountPersistenceAdapter
    │           └── SpringDataAccountRepository
    ├── domain
    │   ├── Account
    │   └── Activity
    └── application
        └── SendMoneyService
        └── Port
            ├── in
            │   └── SendMoneyUseCase
            └── out
                ├── LoadAccountPort
                └── UpdateAccountStatePort
```
구조의 각 요소들은 다음과 같이 패키지 하나씩에 직접 매핑된다.

- `account` 패키지 : 최상위에 위치하여 Account와 관련된 유스케이스를 구현한 모듈임을 나타낸다.

- `domain` 패키지 : `application` 패키지는 도메인 모델을 둘러싼 서비스 계층을 포함한다. `SendMoneyService`는 인커밍 포트 인터페이스인 `SendMoneyUseCase`를 구현하고, 아웃고잉 포트 인터페이스이자 영속성 어댑터에 의해 구현된 `LoadAccountPort`와 `UpdateAccountStatePort`를 사용한다.

- `adapter` 패키지 : 애플리케이션 계층의 인커밍 포트를 호출하는 인커밍 어댑터와 애플리케이션 계층의 아웃고잉 포트에 대한 구현을 제공하는 아웃고잉 어댑터를 포함한다. BuckPal 예제의 경우 각각의 하위 패키지를 가진 `web`과 `persistence` 어댑터로 이뤄져 있다.

이처럼 표현력 있는 패키지 구조는 아키텍처에 대한 적극적인 사고를 촉진한다. 많은 패키지가 생기고, 현재 작업 중인 코드를 어떤 패키지에 넣어야 할지 계속 생각하도록 만든다.

패키지가 아주 많으니 모든 것을 public으로 만들어서 패키지 간의 접근을 허용해야 할까?

어댑터 패키지는 그렇지 않다. 이 패키지에 있는 모든 클래스들은 `application` 패키지 내에 있는 포트 인터페이스를 통하지 않고는 바깥에서 호출되지 않기 때문에 `package-private` 접근 수준으로 둬도 된다.

하지만 `application` 패키지와 `domain` 패키지 내의 일부 클래스들은 `public`으로 지정해야 한다. 어댑터에서 접근 가능해야 하는 포트들, 도메인 클래스들은 `public`이어야 한다. 서비스는 인커밍 포트 인터페이스 뒤에 숨겨질 수 있기 때문에 `public`일 필요가 없다.

어댑터 코드를 자체 패키지로 이동시키면 필요할 경우 다른 구현체로 쉽게 교체할 수 있다는 장점도 있다. 예를 들어, 키-밸류 데이터베이스를 임시로 사용하여 개발을 진행하다가 SQL 데이터베이스로 교체해야 한다고 가정해보자. 간단하게 관련 아웃고잉 포트들만 새로운 어댑터 패키지에 구현하고 기존 패키지를 지우면 된다.

이 패키지 구조의 또 다른 장점은 DDD 개념에 직접적으로 대응시킬 수 있다는 점이다. 예제에서 `account` 같은 상위 레벨 패키지는 다른 바운디드 컨텍스트와 통신할 진입점과 출구(포트)를 포함하는 바운디드 컨텍스트에 해당한다. `domain` 패키지 내에서는 DDD의 주요 개념들을 이용해 어떤 도메인 모델이든 만들어도 된다.
> 바운디드 컨텍스트(bounded-context) : DDD의 주요 개념으로 도메인 모델이 적용되는 논리적 구역. 각 바운디드 컨텍스트는 독립적인 도메인 모델을 가지며, 이를 통해 복잡한 시스템을 여러 개의 부분(패키지)으로 나눈다.
{: .prompt-tip}

## 의존성 주입의 역할
앞에서 설명한 패키지 구조가 클린 아키텍처에 도움이 되기는 하지만, 클린 아키텍처의 가장 본질적인 요건은 2장에서 언급했듯이 애플리케이션 계층이 인커밍/아웃고잉 어댑터에 의존성을 갖지 않는 것이다.

예제에선 제어 흐름의 방향이 어댑터와 도메인 코드 간의 의존성 방향과 같은 방향이기 때문에 그렇게 하기가 수월하다. 어댑터는 애플리케이션 계층에 위치한 서비스를 호출하기만 하면 되지만 어플리케이션 계층으로의 진입점을 구분 짓기 위해 실제 서비스를 포트 인터페이스들 사이에 숨겨두고 싶을 수 있다.

예제의 영속성 어댑터와 같이 아웃고잉 어댑터에 대해서는 제어 흐름의 반대 방향으로 의존성을 돌리기 위해 의존성 역전 원칙을 이용해야 한다. 앞서 살펴봤듯 애플리케이션 계층에 인터페이스를 만들고 어댑터에 해당 인터페이스를 구현한 클래스를 두면 된다. 헥사고날 아키텍처에서는 이 인터페이스를 포트라고 한다. 애플리케이션 계층은 어댑터의 기능을 실행하기 위해 이 포트 인터페이스를 호출한다.

그런데 포트 인터페이스를 구현한 실제 객체를 누가 애플리케이션 계층에 제공해야 할까? 포트를 애플리케이션 계층 안에서 수동으로 초기화하면 애플리케이션 계층에 어댑터에 대한 의존성이 추가되어 바람직하지 않다.

이 부분에서 의존성 주입을 활용할 수 있다. 모든 계층에 의존성을 가진 중립적인 컴포넌트를 하나 도입하는 것이다. 이 컴포넌트는 아키텍처를 구성하는 대부분의 클래스를 초기화하는 역할을 한다.

![그림3.4](/assets/img/study/clean_architecture/example_image_3_4.png)
위 그림에서 중립적인 의존성 주입 컴포넌트는 `AccountController`, `SendMoneyService`, `AccountPersistenceAdapter` 클래스의 인스턴스를 만들 것이다. `AccountController`가 `SendMoneyUseCase` 인터페이스를 필요로 하기 때문에 의존성 주입을 통해 `SendMoneyService` 클래스의 인스턴스를 주입한다. 컨트롤러는 인터페이스만 알면 되기 때문에 자신이 `SendMoneyService` 인스턴스를 실제로 가지고 있는지도 모른다.

이와 비슷하게 `SendMoneyService` 인스턴스를 만들 때도 의존성 주입 매커니즘이 `LoadAccountPort` 인터페이스로 가장한 `AccountPersistenceAdapter` 클래스의 인스턴스를 주입할 것이다.

## 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?
이번 장에서 살펴봤던 헥사고날 아키텍처의 패키지 구조는 코드에서 아키텍처의 특정 요소를 찾으려면 아키텍처 다이어그램의 박스 이름을 따라 패키지 구조를 탐색하면 된다. 이로써 의사소통, 개발, 유지보수의 과정이 수월해진다.